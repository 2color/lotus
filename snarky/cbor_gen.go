// Code generated by github.com/whyrusleeping/cbor-gen. DO NOT EDIT.

package snarky

import (
	"fmt"
	"io"
	"math"
	"sort"

	abi "github.com/filecoin-project/go-state-types/abi"
	paych "github.com/filecoin-project/specs-actors/actors/builtin/paych"
	cid "github.com/ipfs/go-cid"
	cbg "github.com/whyrusleeping/cbor-gen"
	xerrors "golang.org/x/xerrors"
)

var _ = xerrors.Errorf
var _ = cid.Undef
var _ = math.E
var _ = sort.Sort

func (t *PriceRequest) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write([]byte{162}); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.ProofClass (int64) (int64)
	if len("ProofClass") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"ProofClass\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("ProofClass"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("ProofClass")); err != nil {
		return err
	}

	if t.ProofClass >= 0 {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.ProofClass)); err != nil {
			return err
		}
	} else {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajNegativeInt, uint64(-t.ProofClass-1)); err != nil {
			return err
		}
	}

	// t.ProofType (int64) (int64)
	if len("ProofType") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"ProofType\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("ProofType"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("ProofType")); err != nil {
		return err
	}

	if t.ProofType >= 0 {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.ProofType)); err != nil {
			return err
		}
	} else {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajNegativeInt, uint64(-t.ProofType-1)); err != nil {
			return err
		}
	}
	return nil
}

func (t *PriceRequest) UnmarshalCBOR(r io.Reader) error {
	*t = PriceRequest{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajMap {
		return fmt.Errorf("cbor input should be of type map")
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("PriceRequest: map struct too large (%d)", extra)
	}

	var name string
	n := extra

	for i := uint64(0); i < n; i++ {

		{
			sval, err := cbg.ReadStringBuf(br, scratch)
			if err != nil {
				return err
			}

			name = string(sval)
		}

		switch name {
		// t.ProofClass (int64) (int64)
		case "ProofClass":
			{
				maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
				var extraI int64
				if err != nil {
					return err
				}
				switch maj {
				case cbg.MajUnsignedInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 positive overflow")
					}
				case cbg.MajNegativeInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 negative oveflow")
					}
					extraI = -1 - extraI
				default:
					return fmt.Errorf("wrong type for int64 field: %d", maj)
				}

				t.ProofClass = int64(extraI)
			}
			// t.ProofType (int64) (int64)
		case "ProofType":
			{
				maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
				var extraI int64
				if err != nil {
					return err
				}
				switch maj {
				case cbg.MajUnsignedInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 positive overflow")
					}
				case cbg.MajNegativeInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 negative oveflow")
					}
					extraI = -1 - extraI
				default:
					return fmt.Errorf("wrong type for int64 field: %d", maj)
				}

				t.ProofType = int64(extraI)
			}

		default:
			// Field doesn't exist on this type, so ignore it
			cbg.ScanForLinks(r, func(cid.Cid) {})
		}
	}

	return nil
}
func (t *PriceResponse) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write([]byte{164}); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.Accept (bool) (bool)
	if len("Accept") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"Accept\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("Accept"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("Accept")); err != nil {
		return err
	}

	if err := cbg.WriteBool(w, t.Accept); err != nil {
		return err
	}

	// t.Price (big.Int) (struct)
	if len("Price") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"Price\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("Price"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("Price")); err != nil {
		return err
	}

	if err := t.Price.MarshalCBOR(w); err != nil {
		return err
	}

	// t.Address (address.Address) (struct)
	if len("Address") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"Address\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("Address"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("Address")); err != nil {
		return err
	}

	if err := t.Address.MarshalCBOR(w); err != nil {
		return err
	}

	// t.Error (string) (string)
	if len("Error") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"Error\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("Error"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("Error")); err != nil {
		return err
	}

	if len(t.Error) > cbg.MaxLength {
		return xerrors.Errorf("Value in field t.Error was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len(t.Error))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string(t.Error)); err != nil {
		return err
	}
	return nil
}

func (t *PriceResponse) UnmarshalCBOR(r io.Reader) error {
	*t = PriceResponse{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajMap {
		return fmt.Errorf("cbor input should be of type map")
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("PriceResponse: map struct too large (%d)", extra)
	}

	var name string
	n := extra

	for i := uint64(0); i < n; i++ {

		{
			sval, err := cbg.ReadStringBuf(br, scratch)
			if err != nil {
				return err
			}

			name = string(sval)
		}

		switch name {
		// t.Accept (bool) (bool)
		case "Accept":

			maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
			if err != nil {
				return err
			}
			if maj != cbg.MajOther {
				return fmt.Errorf("booleans must be major type 7")
			}
			switch extra {
			case 20:
				t.Accept = false
			case 21:
				t.Accept = true
			default:
				return fmt.Errorf("booleans are either major type 7, value 20 or 21 (got %d)", extra)
			}
			// t.Price (big.Int) (struct)
		case "Price":

			{

				if err := t.Price.UnmarshalCBOR(br); err != nil {
					return xerrors.Errorf("unmarshaling t.Price: %w", err)
				}

			}
			// t.Address (address.Address) (struct)
		case "Address":

			{

				if err := t.Address.UnmarshalCBOR(br); err != nil {
					return xerrors.Errorf("unmarshaling t.Address: %w", err)
				}

			}
			// t.Error (string) (string)
		case "Error":

			{
				sval, err := cbg.ReadStringBuf(br, scratch)
				if err != nil {
					return err
				}

				t.Error = string(sval)
			}

		default:
			// Field doesn't exist on this type, so ignore it
			cbg.ScanForLinks(r, func(cid.Cid) {})
		}
	}

	return nil
}
func (t *WorkRequest) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write([]byte{164}); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.Payment (snarky.PaymentData) (struct)
	if len("Payment") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"Payment\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("Payment"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("Payment")); err != nil {
		return err
	}

	if err := t.Payment.MarshalCBOR(w); err != nil {
		return err
	}

	// t.ProveCommitRequest (snarky.ProveCommitRequest) (struct)
	if len("ProveCommitRequest") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"ProveCommitRequest\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("ProveCommitRequest"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("ProveCommitRequest")); err != nil {
		return err
	}

	if err := t.ProveCommitRequest.MarshalCBOR(w); err != nil {
		return err
	}

	// t.ProofClass (int64) (int64)
	if len("ProofClass") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"ProofClass\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("ProofClass"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("ProofClass")); err != nil {
		return err
	}

	if t.ProofClass >= 0 {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.ProofClass)); err != nil {
			return err
		}
	} else {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajNegativeInt, uint64(-t.ProofClass-1)); err != nil {
			return err
		}
	}

	// t.ProofType (int64) (int64)
	if len("ProofType") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"ProofType\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("ProofType"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("ProofType")); err != nil {
		return err
	}

	if t.ProofType >= 0 {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.ProofType)); err != nil {
			return err
		}
	} else {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajNegativeInt, uint64(-t.ProofType-1)); err != nil {
			return err
		}
	}
	return nil
}

func (t *WorkRequest) UnmarshalCBOR(r io.Reader) error {
	*t = WorkRequest{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajMap {
		return fmt.Errorf("cbor input should be of type map")
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("WorkRequest: map struct too large (%d)", extra)
	}

	var name string
	n := extra

	for i := uint64(0); i < n; i++ {

		{
			sval, err := cbg.ReadStringBuf(br, scratch)
			if err != nil {
				return err
			}

			name = string(sval)
		}

		switch name {
		// t.Payment (snarky.PaymentData) (struct)
		case "Payment":

			{

				b, err := br.ReadByte()
				if err != nil {
					return err
				}
				if b != cbg.CborNull[0] {
					if err := br.UnreadByte(); err != nil {
						return err
					}
					t.Payment = new(PaymentData)
					if err := t.Payment.UnmarshalCBOR(br); err != nil {
						return xerrors.Errorf("unmarshaling t.Payment pointer: %w", err)
					}
				}

			}
			// t.ProveCommitRequest (snarky.ProveCommitRequest) (struct)
		case "ProveCommitRequest":

			{

				b, err := br.ReadByte()
				if err != nil {
					return err
				}
				if b != cbg.CborNull[0] {
					if err := br.UnreadByte(); err != nil {
						return err
					}
					t.ProveCommitRequest = new(ProveCommitRequest)
					if err := t.ProveCommitRequest.UnmarshalCBOR(br); err != nil {
						return xerrors.Errorf("unmarshaling t.ProveCommitRequest pointer: %w", err)
					}
				}

			}
			// t.ProofClass (int64) (int64)
		case "ProofClass":
			{
				maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
				var extraI int64
				if err != nil {
					return err
				}
				switch maj {
				case cbg.MajUnsignedInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 positive overflow")
					}
				case cbg.MajNegativeInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 negative oveflow")
					}
					extraI = -1 - extraI
				default:
					return fmt.Errorf("wrong type for int64 field: %d", maj)
				}

				t.ProofClass = int64(extraI)
			}
			// t.ProofType (int64) (int64)
		case "ProofType":
			{
				maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
				var extraI int64
				if err != nil {
					return err
				}
				switch maj {
				case cbg.MajUnsignedInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 positive overflow")
					}
				case cbg.MajNegativeInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 negative oveflow")
					}
					extraI = -1 - extraI
				default:
					return fmt.Errorf("wrong type for int64 field: %d", maj)
				}

				t.ProofType = int64(extraI)
			}

		default:
			// Field doesn't exist on this type, so ignore it
			cbg.ScanForLinks(r, func(cid.Cid) {})
		}
	}

	return nil
}
func (t *WorkResponse) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write([]byte{162}); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.JobID (string) (string)
	if len("JobID") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"JobID\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("JobID"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("JobID")); err != nil {
		return err
	}

	if len(t.JobID) > cbg.MaxLength {
		return xerrors.Errorf("Value in field t.JobID was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len(t.JobID))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string(t.JobID)); err != nil {
		return err
	}

	// t.Error (string) (string)
	if len("Error") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"Error\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("Error"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("Error")); err != nil {
		return err
	}

	if len(t.Error) > cbg.MaxLength {
		return xerrors.Errorf("Value in field t.Error was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len(t.Error))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string(t.Error)); err != nil {
		return err
	}
	return nil
}

func (t *WorkResponse) UnmarshalCBOR(r io.Reader) error {
	*t = WorkResponse{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajMap {
		return fmt.Errorf("cbor input should be of type map")
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("WorkResponse: map struct too large (%d)", extra)
	}

	var name string
	n := extra

	for i := uint64(0); i < n; i++ {

		{
			sval, err := cbg.ReadStringBuf(br, scratch)
			if err != nil {
				return err
			}

			name = string(sval)
		}

		switch name {
		// t.JobID (string) (string)
		case "JobID":

			{
				sval, err := cbg.ReadStringBuf(br, scratch)
				if err != nil {
					return err
				}

				t.JobID = string(sval)
			}
			// t.Error (string) (string)
		case "Error":

			{
				sval, err := cbg.ReadStringBuf(br, scratch)
				if err != nil {
					return err
				}

				t.Error = string(sval)
			}

		default:
			// Field doesn't exist on this type, so ignore it
			cbg.ScanForLinks(r, func(cid.Cid) {})
		}
	}

	return nil
}
func (t *StatusRequest) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write([]byte{161}); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.JobID (string) (string)
	if len("JobID") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"JobID\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("JobID"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("JobID")); err != nil {
		return err
	}

	if len(t.JobID) > cbg.MaxLength {
		return xerrors.Errorf("Value in field t.JobID was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len(t.JobID))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string(t.JobID)); err != nil {
		return err
	}
	return nil
}

func (t *StatusRequest) UnmarshalCBOR(r io.Reader) error {
	*t = StatusRequest{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajMap {
		return fmt.Errorf("cbor input should be of type map")
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("StatusRequest: map struct too large (%d)", extra)
	}

	var name string
	n := extra

	for i := uint64(0); i < n; i++ {

		{
			sval, err := cbg.ReadStringBuf(br, scratch)
			if err != nil {
				return err
			}

			name = string(sval)
		}

		switch name {
		// t.JobID (string) (string)
		case "JobID":

			{
				sval, err := cbg.ReadStringBuf(br, scratch)
				if err != nil {
					return err
				}

				t.JobID = string(sval)
			}

		default:
			// Field doesn't exist on this type, so ignore it
			cbg.ScanForLinks(r, func(cid.Cid) {})
		}
	}

	return nil
}
func (t *StatusResponse) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write([]byte{163}); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.Status (string) (string)
	if len("Status") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"Status\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("Status"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("Status")); err != nil {
		return err
	}

	if len(t.Status) > cbg.MaxLength {
		return xerrors.Errorf("Value in field t.Status was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len(t.Status))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string(t.Status)); err != nil {
		return err
	}

	// t.Error (string) (string)
	if len("Error") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"Error\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("Error"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("Error")); err != nil {
		return err
	}

	if len(t.Error) > cbg.MaxLength {
		return xerrors.Errorf("Value in field t.Error was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len(t.Error))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string(t.Error)); err != nil {
		return err
	}

	// t.Result (snarky.ProofResult) (struct)
	if len("Result") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"Result\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("Result"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("Result")); err != nil {
		return err
	}

	if err := t.Result.MarshalCBOR(w); err != nil {
		return err
	}
	return nil
}

func (t *StatusResponse) UnmarshalCBOR(r io.Reader) error {
	*t = StatusResponse{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajMap {
		return fmt.Errorf("cbor input should be of type map")
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("StatusResponse: map struct too large (%d)", extra)
	}

	var name string
	n := extra

	for i := uint64(0); i < n; i++ {

		{
			sval, err := cbg.ReadStringBuf(br, scratch)
			if err != nil {
				return err
			}

			name = string(sval)
		}

		switch name {
		// t.Status (string) (string)
		case "Status":

			{
				sval, err := cbg.ReadStringBuf(br, scratch)
				if err != nil {
					return err
				}

				t.Status = string(sval)
			}
			// t.Error (string) (string)
		case "Error":

			{
				sval, err := cbg.ReadStringBuf(br, scratch)
				if err != nil {
					return err
				}

				t.Error = string(sval)
			}
			// t.Result (snarky.ProofResult) (struct)
		case "Result":

			{

				b, err := br.ReadByte()
				if err != nil {
					return err
				}
				if b != cbg.CborNull[0] {
					if err := br.UnreadByte(); err != nil {
						return err
					}
					t.Result = new(ProofResult)
					if err := t.Result.UnmarshalCBOR(br); err != nil {
						return xerrors.Errorf("unmarshaling t.Result pointer: %w", err)
					}
				}

			}

		default:
			// Field doesn't exist on this type, so ignore it
			cbg.ScanForLinks(r, func(cid.Cid) {})
		}
	}

	return nil
}
func (t *ProofResult) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write([]byte{162}); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.Proof (storage.Proof) (slice)
	if len("Proof") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"Proof\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("Proof"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("Proof")); err != nil {
		return err
	}

	if len(t.Proof) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.Proof was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajByteString, uint64(len(t.Proof))); err != nil {
		return err
	}

	if _, err := w.Write(t.Proof[:]); err != nil {
		return err
	}

	// t.Error (string) (string)
	if len("Error") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"Error\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("Error"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("Error")); err != nil {
		return err
	}

	if len(t.Error) > cbg.MaxLength {
		return xerrors.Errorf("Value in field t.Error was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len(t.Error))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string(t.Error)); err != nil {
		return err
	}
	return nil
}

func (t *ProofResult) UnmarshalCBOR(r io.Reader) error {
	*t = ProofResult{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajMap {
		return fmt.Errorf("cbor input should be of type map")
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("ProofResult: map struct too large (%d)", extra)
	}

	var name string
	n := extra

	for i := uint64(0); i < n; i++ {

		{
			sval, err := cbg.ReadStringBuf(br, scratch)
			if err != nil {
				return err
			}

			name = string(sval)
		}

		switch name {
		// t.Proof (storage.Proof) (slice)
		case "Proof":

			maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
			if err != nil {
				return err
			}

			if extra > cbg.ByteArrayMaxLen {
				return fmt.Errorf("t.Proof: byte array too large (%d)", extra)
			}
			if maj != cbg.MajByteString {
				return fmt.Errorf("expected byte array")
			}

			if extra > 0 {
				t.Proof = make([]uint8, extra)
			}

			if _, err := io.ReadFull(br, t.Proof[:]); err != nil {
				return err
			}
			// t.Error (string) (string)
		case "Error":

			{
				sval, err := cbg.ReadStringBuf(br, scratch)
				if err != nil {
					return err
				}

				t.Error = string(sval)
			}

		default:
			// Field doesn't exist on this type, so ignore it
			cbg.ScanForLinks(r, func(cid.Cid) {})
		}
	}

	return nil
}
func (t *ProveCommitRequest) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write([]byte{162}); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.Sector (snarky.SectorRef) (struct)
	if len("Sector") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"Sector\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("Sector"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("Sector")); err != nil {
		return err
	}

	if err := t.Sector.MarshalCBOR(w); err != nil {
		return err
	}

	// t.C1o (storage.Commit1Out) (slice)
	if len("C1o") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"C1o\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("C1o"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("C1o")); err != nil {
		return err
	}

	if len(t.C1o) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.C1o was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajByteString, uint64(len(t.C1o))); err != nil {
		return err
	}

	if _, err := w.Write(t.C1o[:]); err != nil {
		return err
	}
	return nil
}

func (t *ProveCommitRequest) UnmarshalCBOR(r io.Reader) error {
	*t = ProveCommitRequest{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajMap {
		return fmt.Errorf("cbor input should be of type map")
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("ProveCommitRequest: map struct too large (%d)", extra)
	}

	var name string
	n := extra

	for i := uint64(0); i < n; i++ {

		{
			sval, err := cbg.ReadStringBuf(br, scratch)
			if err != nil {
				return err
			}

			name = string(sval)
		}

		switch name {
		// t.Sector (snarky.SectorRef) (struct)
		case "Sector":

			{

				if err := t.Sector.UnmarshalCBOR(br); err != nil {
					return xerrors.Errorf("unmarshaling t.Sector: %w", err)
				}

			}
			// t.C1o (storage.Commit1Out) (slice)
		case "C1o":

			maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
			if err != nil {
				return err
			}

			if extra > cbg.ByteArrayMaxLen {
				return fmt.Errorf("t.C1o: byte array too large (%d)", extra)
			}
			if maj != cbg.MajByteString {
				return fmt.Errorf("expected byte array")
			}

			if extra > 0 {
				t.C1o = make([]uint8, extra)
			}

			if _, err := io.ReadFull(br, t.C1o[:]); err != nil {
				return err
			}

		default:
			// Field doesn't exist on this type, so ignore it
			cbg.ScanForLinks(r, func(cid.Cid) {})
		}
	}

	return nil
}
func (t *PaymentData) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write([]byte{162}); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.From (address.Address) (struct)
	if len("From") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"From\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("From"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("From")); err != nil {
		return err
	}

	if err := t.From.MarshalCBOR(w); err != nil {
		return err
	}

	// t.Voucher (paych.SignedVoucher) (struct)
	if len("Voucher") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"Voucher\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("Voucher"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("Voucher")); err != nil {
		return err
	}

	if err := t.Voucher.MarshalCBOR(w); err != nil {
		return err
	}
	return nil
}

func (t *PaymentData) UnmarshalCBOR(r io.Reader) error {
	*t = PaymentData{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajMap {
		return fmt.Errorf("cbor input should be of type map")
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("PaymentData: map struct too large (%d)", extra)
	}

	var name string
	n := extra

	for i := uint64(0); i < n; i++ {

		{
			sval, err := cbg.ReadStringBuf(br, scratch)
			if err != nil {
				return err
			}

			name = string(sval)
		}

		switch name {
		// t.From (address.Address) (struct)
		case "From":

			{

				if err := t.From.UnmarshalCBOR(br); err != nil {
					return xerrors.Errorf("unmarshaling t.From: %w", err)
				}

			}
			// t.Voucher (paych.SignedVoucher) (struct)
		case "Voucher":

			{

				b, err := br.ReadByte()
				if err != nil {
					return err
				}
				if b != cbg.CborNull[0] {
					if err := br.UnreadByte(); err != nil {
						return err
					}
					t.Voucher = new(paych.SignedVoucher)
					if err := t.Voucher.UnmarshalCBOR(br); err != nil {
						return xerrors.Errorf("unmarshaling t.Voucher pointer: %w", err)
					}
				}

			}

		default:
			// Field doesn't exist on this type, so ignore it
			cbg.ScanForLinks(r, func(cid.Cid) {})
		}
	}

	return nil
}
func (t *SectorRef) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write([]byte{162}); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.ID (abi.SectorID) (struct)
	if len("ID") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"ID\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("ID"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("ID")); err != nil {
		return err
	}

	if err := t.ID.MarshalCBOR(w); err != nil {
		return err
	}

	// t.ProofType (abi.RegisteredSealProof) (int64)
	if len("ProofType") > cbg.MaxLength {
		return xerrors.Errorf("Value in field \"ProofType\" was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len("ProofType"))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string("ProofType")); err != nil {
		return err
	}

	if t.ProofType >= 0 {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.ProofType)); err != nil {
			return err
		}
	} else {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajNegativeInt, uint64(-t.ProofType-1)); err != nil {
			return err
		}
	}
	return nil
}

func (t *SectorRef) UnmarshalCBOR(r io.Reader) error {
	*t = SectorRef{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajMap {
		return fmt.Errorf("cbor input should be of type map")
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("SectorRef: map struct too large (%d)", extra)
	}

	var name string
	n := extra

	for i := uint64(0); i < n; i++ {

		{
			sval, err := cbg.ReadStringBuf(br, scratch)
			if err != nil {
				return err
			}

			name = string(sval)
		}

		switch name {
		// t.ID (abi.SectorID) (struct)
		case "ID":

			{

				if err := t.ID.UnmarshalCBOR(br); err != nil {
					return xerrors.Errorf("unmarshaling t.ID: %w", err)
				}

			}
			// t.ProofType (abi.RegisteredSealProof) (int64)
		case "ProofType":
			{
				maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
				var extraI int64
				if err != nil {
					return err
				}
				switch maj {
				case cbg.MajUnsignedInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 positive overflow")
					}
				case cbg.MajNegativeInt:
					extraI = int64(extra)
					if extraI < 0 {
						return fmt.Errorf("int64 negative oveflow")
					}
					extraI = -1 - extraI
				default:
					return fmt.Errorf("wrong type for int64 field: %d", maj)
				}

				t.ProofType = abi.RegisteredSealProof(extraI)
			}

		default:
			// Field doesn't exist on this type, so ignore it
			cbg.ScanForLinks(r, func(cid.Cid) {})
		}
	}

	return nil
}
